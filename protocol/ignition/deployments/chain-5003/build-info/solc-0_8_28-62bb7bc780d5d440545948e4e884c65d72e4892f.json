{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-62bb7bc780d5d440545948e4e884c65d72e4892f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/LendingPool.sol": "project/contracts/LendingPool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/LendingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract LendingPool {\r\n    IERC20 public immutable collateralToken;\r\n    using SafeERC20 for IERC20;\r\n\r\n    mapping(address => uint256) public sharesOf; // сколько пользователь реально положил в пул\r\n\r\n    uint256 public constant YEAR = 365 days;\r\n    uint256 public totalShares;\r\n    uint256 public sharePriceE18 = 1e18;\r\n    uint256 public lastShareAccrual;\r\n\r\n    // фиксированная годовая ставка 5% в формате 1e18 (0.05 * 1e18)\r\n    uint256 public aprE18 = 5e16;\r\n\r\n    // LTV 50%\r\n    uint256 public constant LTV_BPS = 5000; // 50% in basis points\r\n    uint256 public constant BPS = 10_000;\r\n\r\n    // --- debt side ---\r\n    uint256 public borrowIndexE18 = 1e18;\r\n    uint256 public lastBorrowAccrual;\r\n    uint256 public totalDebtShares;\r\n    mapping(address => uint256) public debtSharesOf;\r\n\r\n    // пока так же 5% годовых (потом вынесем отдельно)\r\n    uint256 public borrowAprE18 = 2e17;\r\n    address public owner;\r\n\r\n    uint256 public liqBonusBps = 1000; // 10% бонус\r\n    uint256 public constant HF_LIQUIDATION_THRESHOLD_E18 = 1e18;\r\n    uint256 public closeFactorBps = 5000;    // можно погасить до 50% долга за раз\r\n\r\n    uint256 public reserveFactorBps = 1000; // 10% от процентов заемщиков в резерв\r\n    uint256 public protocolReserves;        // в токенах (assets)\r\n\r\n\r\n    // --- utilization-based rate model (kink) --- DEC 26\r\n    uint256 public baseBorrowAprE18 = 0;    // e.g. 0%\r\n    uint256 public slope1E18 = 2e17;        // 20% at kink\r\n    uint256 public slope2E18 = 8e17;        // +80% from kink->100%\r\n    uint256 public kinkE18 = 8e17;          // 80% utilization\r\n    event RateModelUpdated(uint256 baseBorrowAprE18, uint256 slope1E18, uint256 kinkE18, uint256 slope2E18);\r\n\r\n\r\n    event ReserveFactorUpdated(uint256 newReserveFactorBps);\r\n    event ReservesAccrued(uint256 interestToSuppliers, uint256 feeToReserves, uint256 protocolReserves);\r\n    event ReservesWithdrawn(address indexed to, uint256 amount);\r\n\r\n    event Deposit(\r\n        address indexed user,\r\n        uint256 assetsIn,\r\n        uint256 sharesMinted,\r\n        uint256 sharePriceE18\r\n    );\r\n\r\n    event Withdraw(\r\n        address indexed user,\r\n        uint256 assetsOut,\r\n        uint256 sharesBurned,\r\n        uint256 sharePriceE18\r\n    );\r\n\r\n    event Borrow(\r\n        address indexed user,\r\n        uint256 assetsOut,\r\n        uint256 debtSharesMinted,\r\n        uint256 borrowIndexE18\r\n    );\r\n\r\n    event Repay(\r\n        address indexed user,\r\n        uint256 assetsPaid,\r\n        uint256 debtSharesBurned,\r\n        uint256 borrowIndexE18\r\n    );\r\n\r\n    event Liquidate(\r\n        address indexed liquidator,\r\n        address indexed user,\r\n        uint256 assetsPaid,\r\n        uint256 debtSharesBurned,\r\n        uint256 collateralSeized,\r\n        uint256 sharesSeized,\r\n        uint256 borrowIndexE18,\r\n        uint256 sharePriceE18\r\n    );\r\n\r\n    event ParamsUpdated(\r\n        uint256 aprE18,\r\n        uint256 borrowAprE18,\r\n        uint256 liqBonusBps,\r\n        uint256 closeFactorBps\r\n    );\r\n\r\n\r\n\r\n    constructor(address _collateralToken) {\r\n        owner = msg.sender;\r\n        collateralToken = IERC20(_collateralToken);\r\n        lastShareAccrual = block.timestamp;\r\n        lastBorrowAccrual = block.timestamp;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    // ======== Setter functions ========\r\n    function setReserveFactor(uint256 newReserveFactorBps) external onlyOwner {\r\n        _accrue();\r\n        _accrueBorrow();\r\n        require(newReserveFactorBps <= 5000, \"reserve factor too high\"); // <=50% MVP cap\r\n        reserveFactorBps = newReserveFactorBps;\r\n        emit ReserveFactorUpdated(newReserveFactorBps);\r\n    }\r\n\r\n    function setApr(uint256 newAprE18) external onlyOwner {\r\n        _accrue(); // закрываем прошлую ставку на текущий момент\r\n        require(newAprE18 <= 5e18, \"apr too high\"); // 500% cap for MVP\r\n        aprE18 = newAprE18;\r\n        emit ParamsUpdated(aprE18, borrowAprE18, liqBonusBps, closeFactorBps);\r\n    }\r\n\r\n    function setBorrowApr(uint256 newBorrowAprE18) external onlyOwner {\r\n        // чтобы не ломать текущие тесты\r\n        _accrueBorrow();\r\n        require(newBorrowAprE18 <= 5e18, \"borrow apr too high\");\r\n\r\n        // backward-compatible field for tests/UI if used\r\n        borrowAprE18 = newBorrowAprE18;\r\n\r\n        // flat model\r\n        baseBorrowAprE18 = newBorrowAprE18;\r\n        slope1E18 = 0;\r\n        slope2E18 = 0;\r\n        kinkE18 = 8e17;\r\n\r\n        emit ParamsUpdated(aprE18, borrowAprE18, liqBonusBps, closeFactorBps);\r\n        emit RateModelUpdated(baseBorrowAprE18, slope1E18, kinkE18, slope2E18);\r\n    }\r\n\r\n\r\n    function setLiqBonus(uint256 newLiqBonusBps) external onlyOwner {\r\n        // фиксировать индексы не обязательно, но это не мешает и делает поведение предсказуемым\r\n        _accrue();\r\n        _accrueBorrow();\r\n\r\n        require(newLiqBonusBps <= 5000, \"liq bonus too high\"); // <=50% for MVP\r\n        liqBonusBps = newLiqBonusBps;\r\n        emit ParamsUpdated(aprE18, borrowAprE18, liqBonusBps, closeFactorBps);\r\n    }\r\n\r\n    function setCloseFactor(uint256 newCloseFactorBps) external onlyOwner {\r\n        _accrue();\r\n        _accrueBorrow();\r\n\r\n        require(newCloseFactorBps > 0 && newCloseFactorBps <= BPS, \"bad close factor\");\r\n        closeFactorBps = newCloseFactorBps;\r\n        emit ParamsUpdated(aprE18, borrowAprE18, liqBonusBps, closeFactorBps);\r\n    }\r\n\r\n    function setRateModel(uint256 newBaseBorrowAprE18, uint256 newSlope1E18, uint256 newKinkE18, uint256 newSlope2E18) external onlyOwner {\r\n        _accrueBorrow();\r\n\r\n        require(newKinkE18 <= 1e18, \"kink > 1\");\r\n        require(newBaseBorrowAprE18 <= 5e18, \"base too high\");\r\n        require(newSlope1E18 <= 5e18, \"slope1 too high\");\r\n        require(newSlope2E18 <= 5e18, \"slope2 too high\");\r\n\r\n        baseBorrowAprE18 = newBaseBorrowAprE18;\r\n        slope1E18 = newSlope1E18;\r\n        kinkE18 = newKinkE18;\r\n        slope2E18 = newSlope2E18;\r\n\r\n        emit RateModelUpdated(baseBorrowAprE18, slope1E18, kinkE18, slope2E18);\r\n    }\r\n\r\n\r\n    // END ======== Setter functions ========\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"zero addr\");\r\n        owner = newOwner;\r\n    }\r\n\r\n\r\n    function _accrue() internal {\r\n        uint256 dt = block.timestamp - lastShareAccrual;\r\n        if (dt == 0) return;\r\n\r\n        // если никто не держит shares — просто сдвигаем якорь времени\r\n        if (totalShares == 0) {\r\n            lastShareAccrual = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        // sharePrice *= (1 + APR * dt / YEAR)\r\n        // uint256 growth = (aprE18 * dt) / YEAR; // growth в 1e18\r\n        // sharePriceE18 = (sharePriceE18 * (1e18 + growth)) / 1e18;\r\n        lastShareAccrual = block.timestamp;\r\n    }\r\n\r\n    function deposit(uint256 amount) external {\r\n        _accrueBorrow();\r\n        _accrue();\r\n        require(amount > 0, \"amount = 0\");\r\n\r\n        collateralToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        uint256 mintedShares = (amount * 1e18 + sharePriceE18 - 1) / sharePriceE18; // ceil\r\n\r\n        totalShares += mintedShares;\r\n        sharesOf[msg.sender] += mintedShares;\r\n\r\n        emit Deposit(msg.sender, amount, mintedShares, sharePriceE18);\r\n    }\r\n\r\n    function _balanceByShares(address user) internal view returns (uint256) {\r\n        uint256 dt = block.timestamp - lastShareAccrual;\r\n        uint256 price = sharePriceE18;\r\n\r\n        if (dt > 0) {\r\n            uint256 growth = (aprE18 * dt) / YEAR;\r\n            price = (price * (1e18 + growth)) / 1e18;\r\n        }\r\n        return (sharesOf[user] * price) / 1e18;\r\n    }\r\n\r\n    function getBalanceWithInterest(address user) external view returns (uint256) {\r\n        return collateralValue(user);\r\n    }\r\n\r\n    function withdraw(uint256 amount) external {\r\n        // в withdraw() сначала _accrue() (обновляет sharePriceE18), \r\n        // и дальше используется именно обновлённая sharePriceE18. \r\n        // Поэтому _currentSharePriceE18() в view должен возвращать точно такую же цену, \r\n        // какую бы получил withdraw() после _accrue(). \r\n        // Если _currentSharePriceE18() у меня именно “sharePriceE18 с учётом виртуального роста dt”, то ок.\r\n        // Не знаю, как правильнее.\r\n\r\n        _accrueBorrow(); // важен порядок\r\n        _accrue(); //(обновляет sharePriceE18)\r\n\r\n        require(amount > 0, \"amount = 0\");\r\n        require(healthOkAfterWithdraw(msg.sender, amount), \"withdraw breaks LTV\");\r\n\r\n        uint256 max = (sharesOf[msg.sender] * sharePriceE18) / 1e18;\r\n        require(amount <= max, \"not enough balance\");\r\n\r\n        // сколько shares надо сжечь, чтобы получить amount токенов\r\n        uint256 sharesToBurn = (amount * 1e18 + sharePriceE18 - 1) / sharePriceE18; // ceil\r\n        require(sharesOf[msg.sender] >= sharesToBurn, \"not enough shares\");\r\n\r\n        sharesOf[msg.sender] -= sharesToBurn;\r\n        totalShares -= sharesToBurn;\r\n\r\n        // отдаём токены (если в пуле есть ликвидность)\r\n        collateralToken.safeTransfer(msg.sender, amount);\r\n\r\n        emit Withdraw(msg.sender, amount, sharesToBurn, sharePriceE18);\r\n    }\r\n\r\n    function maxWithdraw(address user) external view returns (uint256) {\r\n        uint256 c = collateralValue(user);\r\n        uint256 d = debtOf(user);\r\n\r\n        // быстрые и корректные случаи\r\n        if (d == 0) return c;\r\n\r\n        uint256 minCollateral = (d * BPS + LTV_BPS - 1) / LTV_BPS; // ceil\r\n        if (c <= minCollateral) return 0;\r\n\r\n        // уточнение через shares-логику\r\n        uint256 hi = c - minCollateral;\r\n        uint256 lo = 0;\r\n\r\n        while (lo < hi) {\r\n            uint256 mid = (lo + hi + 1) / 2;\r\n            if (healthOkAfterWithdraw(user, mid)) {\r\n                lo = mid;\r\n            } else {\r\n                hi = mid - 1;\r\n            }\r\n        }\r\n        return lo;\r\n    }\r\n\r\n    function collateralValue(address user) public view returns (uint256) {\r\n        uint256 userShares = sharesOf[user];\r\n        if (userShares == 0) return 0;\r\n\r\n        uint256 price = _currentSharePriceE18();\r\n        return (sharesOf[user] * price) / 1e18;\r\n    }\r\n\r\n    function maxBorrow(address user) public view returns (uint256) {\r\n        uint256 collateral = collateralValue(user);\r\n        if (collateral == 0) return 0;\r\n\r\n        uint256 limit = (collateral * LTV_BPS) / BPS; // / 10000\r\n        uint256 d = debtOf(user);\r\n\r\n        if (limit <= d) return 0;\r\n        return limit - d;\r\n    }\r\n\r\n    function borrow(uint256 amount) external {\r\n        _accrue();        // депозитный индекс\r\n        _accrueBorrow();  // индекс долга\r\n\r\n        require(amount > 0, \"amount = 0\");\r\n\r\n        // проверка лимита по LTV\r\n        uint256 avail = maxBorrow(msg.sender);\r\n        require(amount <= avail, \"borrow > limit\");\r\n\r\n        // проверка ликвидности пула\r\n        uint256 poolBal = collateralToken.balanceOf(address(this));\r\n        require(amount <= poolBal, \"not enough liquidity\");\r\n\r\n        // mint debt shares (ceil)\r\n        uint256 shares = (amount * 1e18) / borrowIndexE18;\r\n        if ((shares * borrowIndexE18) / 1e18 < amount) {\r\n            shares += 1;\r\n        }\r\n\r\n        debtSharesOf[msg.sender] += shares;\r\n        totalDebtShares += shares;\r\n\r\n        collateralToken.safeTransfer(msg.sender, amount); // выдача займа\r\n\r\n        emit Borrow(msg.sender, amount, shares, borrowIndexE18);\r\n    }\r\n\r\n    // Начисление процентов по долгу\r\n    function _accrueBorrow() internal {\r\n        uint256 dt = block.timestamp - lastBorrowAccrual;\r\n        if (dt == 0) return;\r\n\r\n        if (totalDebtShares == 0) {\r\n             //если долга нет, индекс долга расти не должен, иначе первый заемщик “платит за время, когда никто не занимал”.\r\n            lastBorrowAccrual = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 oldIdx = borrowIndexE18;\r\n\r\n        uint256 util = _utilizationE18WithIndex(oldIdx);\r\n        uint256 borrowRate = _borrowRateE18(util);\r\n        uint256 growth = (borrowRate * dt) / YEAR; // 1e18\r\n\r\n        uint256 newIdx = (oldIdx * (1e18 + growth)) / 1e18;\r\n        borrowIndexE18 = newIdx;\r\n        lastBorrowAccrual = block.timestamp;\r\n\r\n        // ---- compute interest in ASSETS on total debt ----\r\n        // totalDebtAssets = totalDebtShares * idx / 1e18\r\n        uint256 oldDebtAssets = (totalDebtShares * oldIdx) / 1e18;\r\n        uint256 newDebtAssets = (totalDebtShares * newIdx) / 1e18;\r\n\r\n        if (newDebtAssets <= oldDebtAssets) return;\r\n        uint256 interestAssets = newDebtAssets - oldDebtAssets;\r\n\r\n        // ---- split interest: fee to reserves, rest to suppliers ----\r\n        uint256 fee = (interestAssets * reserveFactorBps) / BPS;\r\n        uint256 toSuppliers = interestAssets - fee;\r\n\r\n        protocolReserves += fee;\r\n\r\n        // ---- credit suppliers by increasing sharePrice using toSuppliers ----\r\n        // sharePrice += toSuppliers / totalShares\r\n        // Only if someone is supplying; otherwise don't increase price.\r\n        if (totalShares > 0 && toSuppliers > 0) {\r\n            // deltaPriceE18 = toSuppliers * 1e18 / totalShares\r\n            uint256 deltaPriceE18 = (toSuppliers * 1e18) / totalShares;\r\n            if (deltaPriceE18 > 0) {\r\n                sharePriceE18 += deltaPriceE18;\r\n            }\r\n        }\r\n\r\n        emit ReservesAccrued(toSuppliers, fee, protocolReserves);\r\n        // Позже можно добавить withdrawReserves(to) и ограничить на balanceOf - totalUserClaims.\r\n    }\r\n\r\n\r\n    function debtOf(address user) public view returns (uint256) {\r\n        uint256 idx = _currentBorrowIndexE18();\r\n        return (debtSharesOf[user] * idx) / 1e18;\r\n    }\r\n\r\n    //Любая state-changing функция сначала фиксирует индексы (_accrue*()),\r\n    // а потом работает ТОЛЬКО со state-значениями (borrowIndexE18, sharePriceE18).\r\n\r\n    // invariant: user never overpays due to rounding\r\n    function repay(uint256 amount) external {\r\n        _accrueBorrow();\r\n        require(amount > 0, \"amount = 0\");\r\n\r\n        uint256 idx = borrowIndexE18; // borrowIndexE18 — индекс, выросший со временем\r\n        uint256 debtShares = debtSharesOf[msg.sender]; // сколько “долговых долей”\r\n        require(debtShares > 0, \"no debt\");\r\n\r\n        uint256 debtAssets = (debtShares * idx) / 1e18;\r\n        uint256 pay = amount > debtAssets ? debtAssets : amount;\r\n        require(pay > 0, \"repay too small\");\r\n\r\n        // burn shares by PAY assets (CEIL) so that burned debt >= intended pay\r\n        uint256 sharesToBurn = (pay * 1e18 + idx - 1) / idx; // ceil\r\n        if (sharesToBurn > debtShares) sharesToBurn = debtShares;\r\n\r\n        // align transfer amount with actual shares burned (user never overpays)\r\n        pay = (sharesToBurn * idx) / 1e18; // floor (exact for shares)\r\n        require(pay > 0, \"repay too small\");\r\n\r\n        debtSharesOf[msg.sender] = debtShares - sharesToBurn;\r\n        totalDebtShares -= sharesToBurn;\r\n\r\n        collateralToken.safeTransferFrom(msg.sender, address(this), pay);\r\n\r\n        emit Repay(msg.sender, pay, sharesToBurn, idx);\r\n    }\r\n\r\n// old almost correct\r\n    // function repay(uint256 amount) external {\r\n\r\n    //     _accrueBorrow();\r\n    //     require(amount > 0, \"amount = 0\");\r\n\r\n    //     uint256 debtAssets = debtOf(msg.sender);\r\n    //     require(debtAssets > 0, \"no debt\");\r\n\r\n    //     uint256 pay = amount > debtAssets ? debtAssets : amount;\r\n\r\n    //     // burn shares corresponding to pay (ceil)\r\n    //     uint256 sharesToBurn = (pay * 1e18) / borrowIndexE18;\r\n    //     if ((sharesToBurn * borrowIndexE18) / 1e18 < pay) {\r\n    //         sharesToBurn += 1;\r\n    //     }\r\n    //     if (sharesToBurn > debtSharesOf[msg.sender]) {\r\n    //         sharesToBurn = debtSharesOf[msg.sender]; // на всякий случай от округления\r\n    //     }\r\n\r\n    //     // align transfer amount with actual shares burned\r\n    //     pay = (sharesToBurn * borrowIndexE18) / 1e18;\r\n    //     require(pay > 0, \"repay too small\");\r\n\r\n    //     debtSharesOf[msg.sender] -= sharesToBurn;\r\n    //     totalDebtShares -= sharesToBurn;\r\n\r\n    //     collateralToken.safeTransferFrom(msg.sender, address(this), pay); // забираем токены у пользователя\r\n    // }\r\n\r\n\r\n    // keeps your caps: close factor, debt, collateral/bonus; and keeps \"no overpay\" invariant.\r\n        // liquidity check после _seizeCollateralShares(). \r\n        // Если не хватает ликвидности, транзакция ревертнется и все изменения откатятся\r\n        // это безопасно, просто чуть неэффективно по газу. Для MVP норм.\r\n\r\n     function liquidate(address user, uint256 repayAmount) external {\r\n        require(repayAmount > 0, \"amount = 0\");\r\n\r\n        _accrue();\r\n        _accrueBorrow();\r\n\r\n        require(healthFactorE18(user) < HF_LIQUIDATION_THRESHOLD_E18, \"health factor ok\");\r\n\r\n        uint256 userDebtShares = debtSharesOf[user];\r\n        require(userDebtShares > 0, \"no debt\");\r\n\r\n        // use state directly (after accrue)\r\n        uint256 idx = borrowIndexE18;\r\n        uint256 price = sharePriceE18;\r\n\r\n        uint256 debtAssets = (userDebtShares * idx) / 1e18;\r\n        uint256 collateralAssets = (sharesOf[user] * price) / 1e18;\r\n\r\n        uint256 payTarget = _liquidationPay(repayAmount, debtAssets, collateralAssets);\r\n\r\n        uint256 sharesToBurn = (payTarget * 1e18 + idx - 1) / idx; // ceil\r\n        if (sharesToBurn > userDebtShares) sharesToBurn = userDebtShares;\r\n        require(sharesToBurn > 0, \"repay too small\");\r\n\r\n        uint256 pay = (sharesToBurn * idx) / 1e18;\r\n        require(pay > 0, \"repay too small\");\r\n\r\n        // collateral must cover seize for actual pay\r\n        require(\r\n            pay <= (collateralAssets * BPS) / (BPS + liqBonusBps),\r\n            \"insufficient collateral\"\r\n        );\r\n\r\n        collateralToken.safeTransferFrom(msg.sender, address(this), pay);\r\n\r\n        debtSharesOf[user] = userDebtShares - sharesToBurn;\r\n        totalDebtShares -= sharesToBurn;\r\n\r\n        uint256 seizeAssets = (pay * (BPS + liqBonusBps)) / BPS;\r\n\r\n        // precompute seizeShares for event (cap)\r\n        uint256 seizeShares = (seizeAssets * 1e18 + price - 1) / price; // ceil\r\n        uint256 uShares = sharesOf[user];\r\n        if (seizeShares > uShares) seizeShares = uShares;\r\n\r\n        uint256 actualSeizeAssets = _seizeCollateralShares(user, seizeAssets, price);\r\n\r\n        require(collateralToken.balanceOf(address(this)) >= actualSeizeAssets, \"not enough liquidity\");\r\n        collateralToken.safeTransfer(msg.sender, actualSeizeAssets);\r\n\r\n        // IMPORTANT: use storage vars directly here to reduce stack pressure\r\n        emit Liquidate(msg.sender,user, pay, sharesToBurn, actualSeizeAssets, seizeShares, borrowIndexE18, sharePriceE18);\r\n    }\r\n\r\n         //     // делаем простую liquidation:\r\n        //     // можно ликвидировать, если healthFactorE18(user) < 1e18\r\n        //     // ликвидатор платит repayAmount (в токенах)\r\n        //     // долг пользователя уменьшается (через burn debtShares)\r\n        //     // ликвидатор получает collateral с бонусом (например +10%)\r\n\r\n\r\n        // Важно: Ликвидация может ревертиться из‑за недостатка ликвидности в пуле\r\n        // liquidate() всегда переводит seizeAssets из пула ликвидатору. \r\n        // Если большая часть средств уже занята заемщиками, баланс пула может быть меньше seizeAssets, \r\n        // ликвидация не сможет пройти. Для MVP это допустимо, но в боевой логике надо либо:\r\n        // liquidate в другом активе (стейбл против залога), либо\r\n        // отдельно учитывать доступную ликвидность и ограничивать seizeAssets.\r\n\r\n    // function liquidate(address user, uint256 repayAmount) external {\r\n    //     require(repayAmount > 0, \"amount = 0\");\r\n\r\n    //     // Ликвидация может упасть, если в пуле нет ликвидности на выплату seizeAssets.\r\n        \r\n    //     // фиксируем индексы как в borrow/repay\r\n    //     _accrue();\r\n    //     _accrueBorrow();\r\n\r\n    //     require(healthFactorE18(user) < HF_LIQUIDATION_THRESHOLD_E18, \"health factor ok\");\r\n\r\n    //     uint256 userDebtShares = debtSharesOf[user];\r\n    //     require(userDebtShares > 0, \"no debt\");\r\n\r\n    //     uint256 idx = borrowIndexE18;\r\n    //     uint256 price = sharePriceE18;\r\n\r\n    //     uint256 debtAssets = (userDebtShares * idx) / 1e18;\r\n    //     uint256 collateralAssets = (sharesOf[user] * price) / 1e18;\r\n\r\n    //     uint256 pay = _liquidationPay(repayAmount, debtAssets, collateralAssets);\r\n\r\n    //     // 1) забираем repay у ликвидатора (сначала деньги)\r\n    //     collateralToken.safeTransferFrom(msg.sender, address(this), pay);\r\n\r\n    //     // 2) сжигаем debtShares пропорционально pay (FLOOR)\r\n    //     _burnDebtSharesByPay(user, pay, idx);\r\n\r\n    //     // 3) считаем сколько залога отдать ликвидатору (pay + bonus)\r\n    //     uint256 seizeAssets = _seizeAssetsFromPay(pay);\r\n\r\n    //     // 4) конвертим seizeAssets в shares (CEIL) и списываем у пользователя\r\n    //     seizeAssets = _seizeCollateralShares(user, seizeAssets, price);\r\n\r\n    //     // 5) проверка ликвидности пула (чтобы не упасть на transfer)\r\n    //     require(collateralToken.balanceOf(address(this)) >= seizeAssets, \"not enough liquidity\");\r\n\r\n    //     // 6) отдаём ликвидатору залог\r\n    //     collateralToken.safeTransfer(msg.sender, seizeAssets);\r\n    // }\r\n\r\n    // pay = min(repayAmount, closeFactor(debt), debt, collateralCap(debt))\r\n    function _liquidationPay(uint256 repayAmount, uint256 debtAssets, uint256 collateralAssets) internal view returns (uint256 pay) {\r\n        pay = repayAmount;\r\n\r\n        // close factor cap\r\n        uint256 closeCap = (debtAssets * closeFactorBps) / BPS;\r\n        if (pay > closeCap) pay = closeCap;\r\n\r\n        // не больше долга\r\n        if (pay > debtAssets) pay = debtAssets;\r\n\r\n        // collateral cap: collateral должен покрыть seize = pay*(1+bonus)\r\n        uint256 maxPayByCollateral = (collateralAssets * BPS) / (BPS + liqBonusBps);\r\n        if (pay > maxPayByCollateral) pay = maxPayByCollateral;\r\n\r\n        require(pay > 0, \"insufficient collateral\");\r\n    }\r\n\r\n    // burn shares by PAID assets (floor)\r\n    function _burnDebtSharesByPay(address user, uint256 pay, uint256 idx) internal {\r\n        uint256 userDebtShares = debtSharesOf[user];\r\n\r\n        uint256 sharesToBurn = (pay * 1e18) / idx; // floor\r\n        if (sharesToBurn > userDebtShares) sharesToBurn = userDebtShares;\r\n        require(sharesToBurn > 0, \"repay too small\");\r\n\r\n        debtSharesOf[user] = userDebtShares - sharesToBurn;\r\n        totalDebtShares -= sharesToBurn;\r\n    }\r\n\r\n    function _seizeAssetsFromPay(uint256 pay) internal view returns (uint256) {\r\n        return (pay * (BPS + liqBonusBps)) / BPS;\r\n    }\r\n\r\n    // returns ACTUAL seizeAssets (может уменьшиться, если у юзера не хватает shares)\r\n    function _seizeCollateralShares(address user, uint256 seizeAssets, uint256 price) internal returns (uint256 actualSeizeAssets) {\r\n        // ceil conversion assets -> shares\r\n        uint256 seizeShares = (seizeAssets * 1e18 + price - 1) / price;\r\n\r\n        uint256 userShares = sharesOf[user];\r\n        if (seizeShares > userShares) {\r\n            seizeShares = userShares;\r\n        }\r\n\r\n        sharesOf[user] = userShares - seizeShares;\r\n        totalShares -= seizeShares;\r\n\r\n        // сколько реально изъяли в assets (floor)\r\n        actualSeizeAssets = (seizeShares * price) / 1e18;\r\n        require(actualSeizeAssets > 0, \"seize too small\");\r\n    }\r\n\r\n    // function _utilizationE18WithIndex(uint256 idxE18) internal view returns (uint256) {\r\n    //     uint256 cash = collateralToken.balanceOf(address(this));\r\n    //     uint256 debtAssets = (totalDebtShares * idxE18) / 1e18;\r\n    //     uint256 denom = cash + debtAssets;\r\n    //     if (denom == 0) return 0;\r\n\r\n    //     return (debtAssets * 1e18) / denom;\r\n    // }\r\n\r\n    function _utilizationE18WithIndex(uint256 idxE18) internal view returns (uint256) {\r\n        uint256 cash = _cashAvailable(); // balance - protocolReserves\r\n        uint256 debtAssets = (totalDebtShares * idxE18) / 1e18;\r\n\r\n        uint256 denom = cash + debtAssets;\r\n        if (denom == 0) return 0;\r\n\r\n        return (debtAssets * 1e18) / denom;\r\n    }\r\n\r\n\r\n    function utilizationE18() public view returns (uint256) {\r\n        // IMPORTANT: use STORAGE index to avoid recursion\r\n        return _utilizationE18WithIndex(borrowIndexE18);\r\n    }\r\n\r\n    function _borrowRateE18(uint256 utilE18) internal view returns (uint256) {\r\n        // kink model:\r\n        // if util <= kink: rate = base + util*slope1/kink\r\n        // else: rate = base + slope1 + (util-kink)*slope2/(1-kink)\r\n        if (utilE18 == 0) return baseBorrowAprE18;\r\n\r\n        uint256 k = kinkE18;\r\n        if (k == 0) return baseBorrowAprE18 + slope1E18 + slope2E18;\r\n\r\n        if (utilE18 <= k) {\r\n            uint256 part = (utilE18 * slope1E18) / k;\r\n            return baseBorrowAprE18 + part;\r\n        } else {\r\n            uint256 excess = utilE18 - k;\r\n            uint256 denom = 1e18 - k;\r\n            if (denom == 0) return baseBorrowAprE18 + slope1E18;\r\n            uint256 part2 = (excess * slope2E18) / denom;\r\n            return baseBorrowAprE18 + slope1E18 + part2;\r\n        }\r\n    }\r\n\r\n\r\n    function pricePerShare() external view returns (uint256) {\r\n        return _currentSharePriceE18();\r\n    }\r\n\r\n    function _currentSharePriceE18() internal view returns (uint256) {\r\n        // если totalShares == 0 — цена не должна “виртуально” расти\r\n        if (totalShares == 0) return sharePriceE18;\r\n\r\n        uint256 dt = block.timestamp - lastShareAccrual;\r\n        if (dt == 0) return sharePriceE18;\r\n\r\n        // если ты отключила aprE18-рост, то просто возвращай sharePriceE18\r\n        return sharePriceE18; // РАНЬШЕ БЫЛО ТОЛЬКО ЭТО\r\n\r\n        // uint256 dt = block.timestamp - lastShareAccrual;\r\n        // uint256 price = sharePriceE18;\r\n\r\n        // if (dt == 0) return price;\r\n        // if (totalShares == 0) return price; // никого нет — цена не растёт\r\n\r\n        // uint256 growth = (aprE18 * dt) / YEAR; // aprE18 (не constant)\r\n        // return (price * (1e18 + growth)) / 1e18;\r\n    }\r\n\r\n    function _currentBorrowIndexE18() internal view returns (uint256) {\r\n        // _currentBorrowIndexE18() — view-виртуальный\r\n        // он может меняться от строки к строке (из-за block.timestamp)\r\n        // он не закрепляется в storage\r\n        // Если использовать его в write-функциях, можно получить:\r\n        // разные значения внутри одной транзакции\r\n        // расхождение между “сколько взяли” и “сколько списали”\r\n        // потенциальные edge-эксплойты через reentrancy / gas-timing\r\n        // Эта функция нужна только в read-only:\r\n        // debtOf()\r\n        // healthFactorE18()\r\n        // maxBorrow()\r\n        // maxWithdraw()\r\n        // фронт / тесты\r\n\r\n        uint256 dt = block.timestamp - lastBorrowAccrual;\r\n        uint256 idx = borrowIndexE18;\r\n\r\n        if (dt == 0) return idx;\r\n        if (totalDebtShares == 0) return idx; // нет долгов — индекс не растёт\r\n\r\n        uint256 util = _utilizationE18WithIndex(idx);\r\n        uint256 borrowRate = _borrowRateE18(util);\r\n        uint256 growth = (borrowRate * dt) / YEAR;\r\n        return (idx * (1e18 + growth)) / 1e18;\r\n\r\n    }\r\n\r\n    function collateralAfterWithdraw(address user, uint256 withdrawAmount) public view returns (uint256) {\r\n        uint256 c = collateralValue(user);\r\n        require(withdrawAmount <= c, \"withdraw > collateral\");\r\n        return c - withdrawAmount;\r\n    }\r\n\r\n    function maxDebtAllowed(uint256 collateralAssets) public pure returns (uint256) {\r\n        return (collateralAssets * LTV_BPS) / BPS;\r\n    }\r\n\r\n    function healthOkAfterWithdraw(address user, uint256 amount) public view returns (bool) {\r\n        //берёшь текущую цену price\r\n        // считаешь sharesToBurn через ceil (как в реальном withdraw)\r\n        // считаешь остаток в shares → остаток collateral в assets\r\n        // проверяешь LTV по этому остаточному collateral\r\n\r\n        uint256 price = _currentSharePriceE18();\r\n        uint256 sharesToBurn = (amount * 1e18 + price - 1) / price; // ceil\r\n        if (sharesToBurn > sharesOf[user]) return false;\r\n\r\n        uint256 remainingShares = sharesOf[user] - sharesToBurn;\r\n        uint256 remainingCollateral = (remainingShares * price) / 1e18;\r\n\r\n        uint256 d = debtOf(user);\r\n        return d <= maxDebtAllowed(remainingCollateral);\r\n    }\r\n\r\n    // read-only метрики без транзакций\r\n    // уметь в тестах/фронте видеть “здоровье” позиции.\r\n    function debtValue(address user) public view returns (uint256) {\r\n        return debtOf(user); // уже есть\r\n    }\r\n\r\n    // LTV = debt / collateral в bps (0..10000)\r\n    function ltvBps(address user) public view returns (uint256) {\r\n        uint256 c = collateralValue(user);\r\n        uint256 d = debtOf(user);\r\n        if (c == 0) return d == 0 ? 0 : type(uint256).max; // вместо деления на 0\r\n        return (d * BPS) / c;\r\n    }\r\n\r\n    // Health Factor (1e18): (collateral * LTV_limit) / debt\r\n    // >1e18 => здорово, <1e18 => можно ликвидировать\r\n    function healthFactorE18(address user) public view returns (uint256) {\r\n        uint256 d = debtOf(user);\r\n        if (d == 0) return type(uint256).max;\r\n\r\n        uint256 c = collateralValue(user);\r\n        if (c == 0) return 0; // нет залога при долге => HF=0, не делим на 0\r\n\r\n        uint256 maxD = (c * LTV_BPS) / BPS; // допустимый долг по лимиту\r\n        if (maxD == 0) return 0; // на всякий случай\r\n        return (maxD * 1e18) / d;\r\n    }\r\n\r\n    function withdrawReserves(address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"zero addr\");\r\n\r\n        _accrue();\r\n        _accrueBorrow();\r\n\r\n        uint256 avail = availableReserves();\r\n        require(amount > 0 && amount <= avail, \"insufficient reserves\");\r\n\r\n        protocolReserves -= amount;\r\n        collateralToken.safeTransfer(to, amount);\r\n\r\n        emit ReservesWithdrawn(to, amount);\r\n    }\r\n\r\n\r\n    struct PositionView {\r\n        uint256 collateralAssets;\r\n        uint256 debtAssets;\r\n        uint256 ltvBps;\r\n        uint256 healthFactorE18;\r\n        uint256 maxBorrowAssets;\r\n        uint256 maxWithdrawAssets;\r\n    }\r\n\r\n    struct PoolView {\r\n        uint256 totalAssets;        // balanceOf(pool)\r\n        uint256 totalDebtAssets;    // totalDebtShares * currentBorrowIndex / 1e18\r\n        uint256 availableLiquidity; // totalAssets (same as balanceOf in single-asset)\r\n        uint256 utilizationE18;     // totalDebt / (totalAssets + totalDebt)\r\n        uint256 sharePriceE18;      // current (virtual)\r\n        uint256 borrowIndexE18;     // current (virtual)\r\n        uint256 supplyAprE18;       // aprE18 (current param)\r\n        uint256 borrowAprE18;       // borrowAprE18 (current param)\r\n        uint256 liqBonusBps;        // param\r\n        uint256 closeFactorBps;     // param\r\n        uint256 reserveFactorBps;\r\n        uint256 protocolReserves;\r\n    }\r\n\r\n    function position(address user) external view returns (PositionView memory p) {\r\n        uint256 c = collateralValue(user);\r\n        uint256 d = debtOf(user);\r\n\r\n        uint256 ltv = 0;\r\n        if (c > 0) ltv = (d * BPS) / c;\r\n\r\n        uint256 hf;\r\n        if (d == 0) hf = type(uint256).max;\r\n        else {\r\n            uint256 maxD = (c * LTV_BPS) / BPS;\r\n            hf = (maxD * 1e18) / d;\r\n        }\r\n\r\n        p = PositionView({\r\n            collateralAssets: c,\r\n            debtAssets: d,\r\n            ltvBps: ltv,\r\n            healthFactorE18: hf,\r\n            maxBorrowAssets: maxBorrow(user),\r\n            maxWithdrawAssets: _maxWithdrawView(user, c, d) // helper below\r\n        });\r\n    }\r\n\r\n    function _maxWithdrawView(address user, uint256 c, uint256 d) internal view returns (uint256) {\r\n        if (d == 0) return c;\r\n\r\n        // quick upper bound (may be slightly optimistic due to rounding),\r\n        // but we refine it with binary search using healthOkAfterWithdraw().\r\n        uint256 minCollateral = (d * BPS + LTV_BPS - 1) / LTV_BPS; // ceil\r\n        if (c <= minCollateral) return 0;\r\n\r\n        uint256 hi = c - minCollateral; // candidate\r\n        // refine with binary search so it never lies to frontend\r\n        return _maxWithdrawBinary(user, hi);\r\n    }\r\n\r\n    function _maxWithdrawBinary(address user, uint256 hi) internal view returns (uint256) {\r\n        uint256 lo = 0;\r\n        while (lo < hi) {\r\n            uint256 mid = (lo + hi + 1) / 2;\r\n            if (healthOkAfterWithdraw(user, mid)) lo = mid;\r\n            else hi = mid - 1;\r\n        }\r\n        return lo;\r\n    }\r\n\r\n    // Для UI/Дашборда\r\n    function poolState() external view returns (PoolView memory s) {\r\n        uint256 curSharePrice = _currentSharePriceE18();\r\n        uint256 curBorrowIndex = _currentBorrowIndexE18();\r\n\r\n        uint256 assets = collateralToken.balanceOf(address(this));\r\n        uint256 debtAssets = (totalDebtShares * curBorrowIndex) / 1e18;\r\n\r\n        uint256 cash = _cashAvailable(); // balance - protocolReserves\r\n        uint256 denom = cash + debtAssets;\r\n        uint256 util = denom == 0 ? 0 : (debtAssets * 1e18) / denom;\r\n\r\n        uint256 bApr = _borrowRateE18(util);\r\n        uint256 sApr = ((bApr * util) / 1e18) * (BPS - reserveFactorBps) / BPS;\r\n\r\n        s = PoolView({\r\n            totalAssets: assets,\r\n            totalDebtAssets: debtAssets,\r\n            availableLiquidity: cash,      // важно: не весь balance, а доступный cash\r\n            utilizationE18: util,\r\n            sharePriceE18: curSharePrice,\r\n            borrowIndexE18: curBorrowIndex,\r\n            supplyAprE18: sApr,\r\n            borrowAprE18: bApr,\r\n            liqBonusBps: liqBonusBps,\r\n            closeFactorBps: closeFactorBps,\r\n            reserveFactorBps: reserveFactorBps,\r\n            protocolReserves: protocolReserves\r\n        });\r\n    }\r\n\r\n    function _cashAvailable() internal view returns (uint256) {\r\n        uint256 bal = collateralToken.balanceOf(address(this));\r\n        if (bal <= protocolReserves) return 0;\r\n        return bal - protocolReserves;\r\n    }\r\n\r\n    function totalSupplyAssets() public view returns (uint256) {\r\n        uint256 price = _currentSharePriceE18();\r\n        return (totalShares * price) / 1e18;\r\n    }\r\n\r\n    function availableReserves() public view returns (uint256) {\r\n        uint256 bal = collateralToken.balanceOf(address(this));\r\n        uint256 owedToSuppliers = totalSupplyAssets();\r\n\r\n        if (bal <= owedToSuppliers) return 0;\r\n\r\n        uint256 free = bal - owedToSuppliers;\r\n\r\n        // protocolReserves — учётная величина, но вывести можно только реальный free\r\n        return free < protocolReserves ? free : protocolReserves;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// СДЕЛАТЬ:\r\n// возвращать в событии фактические pay и seizeAssets, чтобы у фронта были точные цифры."
      }
    }
  }
}